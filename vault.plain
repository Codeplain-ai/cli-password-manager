{% include "python-console-app-template.plain", main_executable_file_name: "vault.py" %}

# Command-Line Password Manager

***Definitions:***

- The Vault is a secure, encrypted data store that holds credential information.
  - The Vault is represented as a single encrypted file on disk (`vault.dat`).
  - The Vault includes a header containing metadata (version, salt, KDF parameters, nonce) and an encrypted payload containing The Entries.
  - The Vault must be readable and writable only by the owner of the file.

- The Entry represents one stored credential inside The Vault.
  - The Entry has the following attributes:
    - ID – a unique identifier (string or UUID).
    - Name – a short description of the service or account.
    - Username – the username or login identifier for the service.
    - Password – the secret associated with The Entry.
    - URL – an optional link or reference to the related service.
    - Notes – optional free-form text.
    - Created At – timestamp of creation.
    - Updated At – timestamp of last modification.

- The User - is a human person who uses The Password Manager to store and manage credentials securely.
  - The User authenticates using The Master Password.
  - The Master Password is never stored in plaintext.
  - The Master Password is used to derive an encryption key for The Vault.

- The Encryption Key is derived from The Master Password using a Key Derivation Function (KDF).
  - The KDF used is Argon2id.
  - The KDF parameters (salt, memory cost, time cost, parallelism) are stored in The Vault header.

- The CLI (Command-Line Interface) is the interface through which The User interacts with The Password Manager.

- The Clipboard is the system clipboard, used to temporarily hold copied passwords.
  - The Clipboard contents must automatically clear after a configurable timeout.

- The Password Generator is a feature that creates secure random passwords according to configurable criteria (length, symbols, digits, etc.).

***Non-Functional Requirements:***

- The Implementation must be written in Python 3.11+.

- Python functions description strings should be composed of single line comments starting with '#'

- The following external libraries must be used:
  - `cryptography` for AES-256-GCM encryption and decryption.
  - `argon2-cffi` for Argon2id key derivation.
  - `click` for the command-line interface.
  - `pyperclip` for clipboard operations.
  - `pytest` for automated testing.

- The Implementation must run entirely offline and store data locally on the user’s machine.

- The default Vault file path must be `~/.local/share/pwmgr/vault.dat` (configurable via CLI).

- All file operations must be performed atomically. Temporary files must not contain plaintext data after completion.

- The Vault file and its directory must have restricted permissions (`0600` for files, `0700` for directories).

- The Vault must be encrypted using AES-256-GCM with a unique 12-byte nonce per encryption.

- The Master Password must be converted into The Encryption Key using Argon2id with random 16-byte salt and stored KDF parameters.

- Nonce reuse must never occur.

- Sensitive memory (plaintexts, keys, passwords) must be cleared after use when possible.

- Clipboard contents must auto-expire after timeout.

- No plaintext secrets may be written to disk at any time, including temporary files or logs.

- The Implementation must handle authentication failure gracefully and securely.

- The imports should be done at the top of the file and not in individual functions as this is bad practice.

***Test Requirements:***

- The Unit Tests must be written in Python using the `pytest` framework.

- The Unit Tests should only test the vital components without being redundant.

- The conformance tests should simulate CLI calls when testing and make sure to get an accurate exit code of the process.

- Some functionalities require user input to work. The conformance tests should simulate or mock the input functions to test these functionalities.

- The mocking of the input functions should be done in the conformance tests so the testing environment should not affect the implementation code. Should use unittest.mock to mock the getpass or getpass.getpass function. Make sure to correctly path the mock function. For example @patch(modulename.filename.getpass)

- The CLI testing should be done with click.testing.CliRunner since testing CLI with a subprocess makes it difficult to mock input functions such as getpass

## Password Functionality 

***Non-Functional Requirements:***

- The code should be implemented in the password_functionality folder.

- The implemented code should be a module that can be used by other modules of The Vault system.

- User inputs that can raise exceptions such as KeyboardInterrupt should be gracefully handled.

***Functional Requirements:***

- Implement a secure password_input function that handles the password input of the User.
  - it should prompt The User for The Master Password with hidden input (no characters displayed on screen)
  - should use getpass.getpass as the user input function
  - it should return the The Users input.

- Implement a password_validation function that checks The Master Password against minimum security requirements
  - The password should be at least 8 characters long and have at least one upper case letter, one lower case letter and a special character
  - The function should return True if the Master Password is valid and False if it is not.

- Implement the setup_password function to setup a Master Password
  - user should input the new Master Password with the password_input function
  - user should then enter the Master Password again with the password_input function
  - if the passwords do not match, throw an error.

## Argon2id Key Management

***Non-Functional Requirements:***

- The code should be implemented in the key_management folder.

- The implemented code should be a module that can be used by other modules of The Vault system.

***Functional Requirements:***

- Implement a function to generate a cryptographically secure random salt for Argon2id KDF using appropriate randomness sources and salt length according to security best practices.

- Implement a function to define default Argon2id parameters (memory cost, time cost, and parallelism)
  - The function should return the set of default Argon2id parameters.

- Implement a function to validate Argon2id parameters to ensure they meet minimum security requirements and fall within acceptable ranges for memory cost, time cost, and parallelism values.

- Implement the core Argon2id key derivation function that takes The Master Password and performs the cryptographic key derivation process using the Argon2id algorithm.
  - The function should take the Master Password and KDF parameters as input and return the derived key
  - The KDF parameters should be obtained from the default Argon2id parameters.

## Encryption

***Non-Functional Requirements:***

- The code should be implemented in the encryption folder.

- The implemented code should be a module that can be used by other modules of The Vault system.

***Functional Requirements:***

- Implement an Encrypt function that encrypts the input string with a given key
  - The function should take the input key and input string and return an encrypted input string

- Implement a Decrypt function that enables the decryption of an encrypted string with a given key
  - The function should take the input key and input encrypted string and return an decrypted input string

## Vault Functions

***Non-Functional Requirements:***

- The code should be implemented in the vault_structure folder.

- The implemented code should be a module that can be used by other modules of The Vault system.

***Functional Requirements:***
- Implement the initialize_empty_payload function
  - The function should create and return an empty payload structure that will contain The Entries in the future.

- Implement the encrypt_payload function that encrypts the Payload and returns the encrypted Payload
  - Take a Payload and encryption key as input and returns the encrypted payload
  - Use the Encrypt function from the encryption module

- Implement a decrypt_payload function that decrypts the Payload and returns the decrypted Payload.
  - Take an encrypted Payload and encryption key as the input and returns the decrypted payload
  - Use the Decrypt function from the encryption module

- Create the Vault class with and init function that sets the vault header and encrypted payload as None if they are not provided.

- Implement the create_vault_header function that creates the Vault header
  - Create a vault header structure containing metadata
  - Metadata should contain cryptographic salt, KDF parameters (memory cost, time cost, parallelism), and encryption nonce required for vault decryption.
  - Obtain the KDF parameters from the encryption module
  - The vault header should be returned in plaintext

- Implement the assemble_vault_structure function
  - Combine the vault header and encrypted payload into a unified vault data structure that maintains the logical organization of metadata and encrypted content

- Implement the create_vault function
  - Get the default cryptographics parameters from the key_management module
  - create The Vault structure with header containing metadata (version, salt, KDF parameters, nonce) and empty encrypted payload for The Entries.

- Create the obtain_key function for the vault Initialization
  - Prompt The User for The Master Password (and confirmation). Use functions in the password_functionality module.
  - Derive The Encryption Key. Use the key_management module.
  - Return The Encryption Key

- Implement an init_vault function
  - Obtain The Encryption key using the obtain_key function.
  - Create an empty vault with the create_vault function.

- Implement a verify_vault function that verifies if the vault file exists and can be accessed.

- Implement the save_vault function that saves the Vault to a file
  - Write The Vault to disk as 'vault.dat'.
  - Verify the vault with the verify_vault function.

- Implement a decrypt_vault function that derives the key and decrypts the vault.
  - Takes the vault object as input
  - Derives the key using the key_management module
  - Decrypts the payload using the decrypt_payload function
  - Returns the decrypted payload

- Implement the load_vault function that loads the vault from a file.
  - Loads the vault file
  - Prompts The User for a password
  - Decrypts the vault Payload using the decrypt_vault function.
  - Returns the decrypted vault

- Create an Entry class with an __init__ method that stores all Entry attributes

- Implement the serialize_entry function in the Entry class that serializes the input entry.

- Implement the enter_entry function that prompts The User for entry details (name, username, password, URL, notes) and creates a new Entry object with all required attributes including auto-generated ID and timestamps.

- Implement the add_entry_to_payload function that takes a new Entry object and adds it to the decrypted vault payload

- Implement an add_entry function that handles the entry of a new entry to the vault by the user
  - Loads the vault from a file using the load_vault function
  - Creates a new Entry through the enter_entry function.
  - Add the new Entry to The Vault payload using the add_entry_to_payload function.
  - Re-encrypt The Vault after modification using the encrypt_payload function
  - Save the vault to file

- Implement a delete_entry_from_payload function that takes an entry name or ID and the decrypted payload as an input and removes the entry.
  - returns the decrypted payload without the deleted entry.

- Implement the delete_entry function that deletes the entry from the Vault
  - Loads the vault from a file using the load_vault function
  - Removes The Entry from the Payload using the delete_entry_from_payload function
  - Re-encrypt The Vault after modification using the encrypt_payload function
  - Save the vault to file

- Implement a get_entry_from_payload function that takes an entry name or ID and the decrypted payload as an input and returns the entry.
  - returns the entry from the decrypted payload.

- Implement a get_entry function that gets the entry from the Vault.
  - Loads the vault from a file using the load_vault function
  - Retrieves the entry from the payload using the get_entry_from_payload function.
  - The Password must only be displayed if the show argument is set to True
  - The Password must only be copied to clipboard if the clip argument is set to True.
  - The clip argument should be set to True by default.

- Implement the edit_entry_in_payload that takes an entry name or ID, the decrypted payload and a new entry as an input and edits the existing entry in the payload.

- Implement the edit_entry function that edits the entry in the Vault.
  - Loads the vault from a file using the load_vault function
  - Creates a new Entry through the enter_entry function.
  - Replaces the Entry in the Payload with the new Entry using the edit_entry_in_payload function.
  - Re-encrypt The Vault after modification using the encrypt_payload function
  - Save the vault to file

- Implement the list_entries function that lists all the entries in the Vault
  - Loads the vault from a file using the load_vault function
  - Displays the usernames and metadata for all entries in the Vault.

- Implement the change_master_password function that changes the Master Password for the vault.
  - Loads the vault from a file using the load_vault function
  - Prompts The User for a password
  - Derives the key using the key_management module
  - Encrypt The Vault using the encrypt_payload function
  - Save the vault to file

## Vault commands

***Non-Functional Requirements:***

- The commands should be implemented in Vault CLI.

- The Vault CLI is defined in the vault.py

***Functional Requirements:***

- Implement the Help function which prints out the usage for The Vault app
  - This Help function should be called if vault.py is run without input arguments.

- Implement an Initialization Command (`init`)
  - The function should call the init_vault function of the vault_structure module.

- Implement an Add Command (`add`) that adds an additional password to the vault
  - The function should call the add_entry function of the vault_structure module.

- Implement the Get Command (`get`) which retrieves the password
  - The function should call the get_entry function of the vault_structure module.

- Implement the Edit Command (`edit`)
  - The function should call the edit_entry function of the vault_structure module.

- Implement the Delete Command (`delete`)
  - The function should call the delete_entry function of the vault_structure module.

- Implement the List Command (`list`)
  - The function should call the list_entries function of the vault_structure module.

- Change Master Command (`change-master`) that changes the Master Password
  - The function should call the change_master_password function of the vault_structure module.
