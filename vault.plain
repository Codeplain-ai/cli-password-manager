# Command-Line Password Manager

***Definitions:***

- :Vault: is a secure, encrypted data store that holds credential information.
  - :Vault: is represented as a single encrypted file on disk (`vault.dat`).
  - :Vault: includes a header containing metadata (version, salt, KDF parameters, nonce) and an encrypted payload containing the stored entries.
  - :Vault: must be readable and writable only by the owner of the file.

- :Entry: represents one stored credential inside the :Vault:.
  - :Entry: has the following attributes:
    - ID – a unique identifier (string or UUID).
    - Name – a short description of the service or account.
    - Username – the username or login identifier for the service or account.
    - Password – the secret associated with the service or account.
    - URL – an optional link or reference to the related service.
    - Notes – optional free-form text.
    - Created At – timestamp of creation.
    - Updated At – timestamp of last modification.

- :Payload: is the encrypted data stored in the :Vault: storage file.
  - :Payload: includes the encrypted entries.

- :VaultHeader: is the metadata stored in the :Vault: storage file.
  - :VaultHeader: includes the version, salt, KDF parameters and nonce.

- :MasterPassword: is the password used to access the :Vault:.
  - :MasterPassword: is never stored in plaintext.
  - :MasterPassword: is used to derive an encryption key for the :Vault:.

- :User: is a human person who uses the :Vault: to store and manage credentials securely.
  - :User: authenticates using the :MasterPassword:.

- :EncryptionKey: is derived from the :MasterPassword: using a Key Derivation Function (KDF).
  - The KDF used is Argon2id.
  - The KDF parameters (salt, memory cost, time cost, parallelism) are stored in the :Vault: header.

- :CLI: (Command-Line Interface) is the interface through which :User: interacts with the :Vault:.

- :Clipboard: is the system clipboard, used to temporarily hold copied passwords.
  - The Clipboard contents must automatically clear after a configurable timeout.

***Non-Functional Requirements:***

- :Implementation: must be written in Python 3.11+.

- The following external libraries must be used in the :Implementation:
  - `cryptography` for AES-256-GCM encryption and decryption.
  - `argon2-cffi` for Argon2id key derivation.
  - `pyperclip` for clipboard operations.
  - `pytest` for automated testing.

- :Implementation: must run entirely offline and store data locally on the :User:'s machine.

- The default :Vault: storage file path must be `~/.local/share/pwmgr/vault.dat` (configurable via the :CLI:).

- All file operations must be performed atomically. Temporary files must not contain plaintext data after completion.

- The :Vault: storage file and its directory must have restricted permissions (`0600` for files, `0700` for directories).

- The :Vault: must be encrypted using AES-256-GCM with a unique 12-byte nonce per encryption.

- The :MasterPassword: must be converted into the :EncryptionKey: using Argon2id with random 16-byte salt and stored KDF parameters.

- Nonce reuse must never occur.

- Sensitive memory (plaintexts, keys, passwords) must be cleared after use when possible.

- :Clipboard: contents must auto-expire after timeout.

- No plaintext secrets may be written to disk at any time, including temporary files or logs.

- :Implementation: must handle authentication failure gracefully and securely.

- The imports should be done at the top of the file and not in individual functions as this is bad practice.

- The :UnitTests: must be written in Python using the `pytest` framework.

- The :UnitTests: should only test the vital components without being redundant.


***Test Requirements:***

- The :ConformanceTests: will be run with `python -m unittest discover`

## Argon2id Key Management

***Non-Functional Requirements:***

- The code should be implemented in the key_management folder.

- The implemented code should be a module that can be used by other modules of The Vault system.

***Functional Requirements:***

- Implement a function to generate a cryptographically secure random salt for Argon2id KDF using appropriate randomness sources and salt length according to security best practices.

- Implement a get_default_params function to define default Argon2id parameters (memory cost, time cost, and parallelism)
  - The function should return the set of default Argon2id parameters.

- Implement the core Argon2id key derivation function
  - The function should take the Master Password and KDF parameters as input and return the derived key
  
- Implement the get_key function that take the Master Password as input, obtains the default KDF parameters or KDF parameters from input and returns the derived key and KDF parameters.

## Encryption

***Non-Functional Requirements:***

- The code should be implemented in the encryption folder.

- The implemented code should be a module that can be used by other modules of the :Vault: system.

- The functions of the key_management module should be used to derive the key and obtain cryptographic parameters.

***Functional Requirements:***

- Implement an Encrypt function that encrypts the input string with a given key
  - The function should take the input key and input string and return an encrypted input string

- Implement a Decrypt function that enables the decryption of an encrypted string with a given key
  - The function should take the input key and input encrypted string and return an decrypted input string

## Password Entries:

***Non-Functional Requirements:***

- The code should be implemented in the password_entries folder.

- The implemented code should be a module that can be used by other modules of The Vault system.

***Functional Requirements:***
- Create an :Entry: class with an __init__ method that stores all :Entry: attributes
  - The :Entry: attributes should include auto-generated ID and timestamp generated in the __init__ function.

## Vault Functions

***Non-Functional Requirements:***

- The code should be implemented in the vault_structure folder.

- The implemented code should be a module that can be used by other modules of The Vault system.

- Use functions from the key_management module for obtaining the keys.

***Functional Requirements:***

- Create the Vault class that initializes the encrypted payload as empty if they are not provided.
  - Takes the encryption key and cryptographic parameters as input

- Implement the create_vault function
  - Get the default cryptographic parameters from the key_management module
  - create The Vault structure with :VaultHeader: containing cryptographic parameters (version, salt, KDF parameters, nonce) and empty :Payload: for the stored entries.

- Implement functionality to encrypt the payload.
  - Take a :Payload: and :EncryptionKey: as input and returns the encrypted :Payload:
  - Use functions from the encryption module

- Implement functionality to decrypt the payload.
  - Take an encrypted :Payload: and :EncryptionKey: as the input and returns the decrypted :Payload:
  - Use functions from the encryption module

- Implement the save_vault function that saves the :Vault: to a storage file
  - Write the :Vault: to disk as 'vault.dat'.
  - The :Payload: should be encrypted and the :VaultHeader: should be in plaintext

- Implement the load_vault function that loads the vault from a file.
  - Loads the :Vault: storage file
  - Decrypts the :Payload: of the :Vault:.
  - Returns the decrypted :Payload: and the :VaultHeader:.
  - Takes an :EncryptionKey: and :Vault: storage file path as input

- Implement an add_entry function that handles the entry of a new entry to the vault by the user
  - Loads the :Vault: from a storage file using the load_vault function
  - Takes an :Entry: object, :Vault: storage file path and :EncryptionKey: as input.
  - Add the new :Entry: to the :Payload: of the :Vault:.
  - Re-encrypt the :Vault: after modification
  - Save the :Vault: to the same storage file path

- Implement the delete_entry function that deletes the :Entry: from the :Vault:
  - Takes an :Entry: ID, storage file path and :EncryptionKey: as input.
  - Loads the :Vault: from a storage file
  - Removes the :Entry: with :Entry: ID from the :Payload: of the :Vault:
  - Re-encrypt the :Vault: after modification
  - Save the :Vault: to the same storage file path

- Implement a get_entry function that gets the :Entry: from the :Vault:.
  - Takes an Entry ID, file path and encryption key as input.
  - Loads the :Vault: from a storage file using the load_vault function
  - Retrieves the :Entry: from the :Payload: of the :Vault: using the get_entry_from_payload function.
  - The :Entry: associated password must only be displayed if the show argument is set to True
  - The :Entry: associated password must only be copied to the :Clipboard: if the clip argument is set to True.
  - The clip argument should be set to True by default.

- Implement the list_entries function that lists all the :Entry: objects in the :Vault:
  - Takes the storage file path and :EncryptionKey: as input.
  - Loads the :Vault: from a storage file using the load_vault function
  - Displays the usernames and metadata for all :Entry: objects in the :Vault:.

- Implement the change_encryption_key function that changes the :EncryptionKey: for the :Vault:.
  - Takes the storage file path, the current :EncryptionKey: and the new :EncryptionKey: as input.
  - Loads the :Vault: from a storage file using the load_vault function
  - Encrypt the :Vault: with the new :EncryptionKey:
  - Save the :Vault: to the same storage file path

## Password Functionality

***Test Requirements:***

- Some functionalities require user input to work. The conformance tests should simulate or mock the input functions to test these functionalities.

- The mocking of the input functions should be done in the conformance tests so the testing environment should not affect the implementation code. Should use unittest.mock to mock the getpass or getpass.getpass function. Make sure to correctly path the mock function. For example @patch(modulename.filename.getpass)


***Non-Functional Requirements:***

- The code should be implemented in the password_functionality folder.

- The implemented code should be a module that can be used by other modules of The Vault system.

- User inputs that can raise exceptions such as KeyboardInterrupt should be gracefully handled.

***Functional Requirements:***

- Implement a secure password_input function that handles the password input of the :User:.
  - it should prompt the :User: for the :MasterPassword: with hidden input (no characters displayed on screen)
  - should use getpass.getpass as the user input function
  - it should return the :User:'s input.

- Implement a password_validation function that checks the :MasterPassword: against minimum security requirements
  - The password should be at least 8 characters long and have at least one upper case letter, one lower case letter and a special character
  - The function should return True if the :MasterPassword: is valid and False if it is not.

- Implement the setup_password function to setup a :MasterPassword:
  - user should input the new :MasterPassword: with the password_input function
  - user should then enter the :MasterPassword: again with the password_input function
  - if the :MasterPassword: and the confirmation :MasterPassword: do not match, throw an error.


## Vault commands

***Non-Functional Requirements:***

- The commands should be implemented in the :CLI:.

- The :CLI: is defined in the vault.py

- The functions from the password_functionality module should be used for password inputs

***Functional Requirements:***

- Implement the Help function which prints out the usage for the :Vault: app
  - This Help function should be called if vault.py is run without input arguments.

- Implement an Initialization Command (`init`)
  - Ask the user for the password
  - Get the :EncryptionKey: and KDF parameters using the get_key function in the key_management module.
  - The function should initialize the :Vault: using the :EncryptionKey: and KDF parameters.

- Implement an Add Command (`add`) that adds an additional password to the :Vault:
  - The function should call the add_entry function of the vault_structure module.

- Implement the Get Command (`get`) which retrieves the :Entry: password
  - Takes an :Entry: ID and the :Vault: storage file path as input.
  - The function should call the get_entry function of the vault_structure module.

- Implement the Delete Command (`delete`)
  - Takes an :Entry: ID and the :Vault: storage file path as input.
  - The function should call the delete_entry function of the vault_structure module.

- Implement the List Command (`list`)
  - Takes the :Vault: storage file path as input.
  - The function should call the list_entries function of the vault_structure module.